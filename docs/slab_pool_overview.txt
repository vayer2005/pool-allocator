────────────────────────────────────────────
Design Overview: Slab Allocator Components
────────────────────────────────────────────

1. Slab  (files: Slab.hpp / Slab.cpp)
--------------------------------------
Role
    • Represents a single page-sized block of memory (e.g., 1 MiB).
    • Splits that block into fixed-size "chunks".
    • Maintains an O(1) intrusive free list for fast allocate / deallocate.

Typical data members
    memory_     – pointer to raw slab memory (from mmap / malloc).
    freeList_   – head of the singly-linked free list.
    chunkSize_  – size of each chunk.

Key operations
    allocate()      – pop head of free list.
    deallocate(ptr) – push ptr back on list.
    empty()         – returns true when all chunks are free.

Invariants
    1. All chunks inside a slab are the same size.
    2. The next-pointer of the free list is stored in the chunk itself.
    3. No extra per-chunk metadata ⇒ zero external fragmentation.

Why it exists
    Provides the constant-time, cache-friendly primitive on which higher layers build.


2. Pool  (file: Pool.hpp)
-------------------------
Role
    • Presents a malloc-like API: allocate(size), deallocate(ptr,size).
    • Holds multiple size classes (64 B, 128 B, 256 B, …).
    • For each size class keeps a list of Slab objects.

Responsibilities
    Size-class routing   – round requested size up to next class.
    Growth               – create new slab when none have space.
    Reclamation          – release slab back to OS when it becomes empty.
    Threading variants   – single-threaded, global lock, per-thread cache, etc.

Typical flow
    Pool::allocate(N):
        idx   ← router(N)
        slab  ← classes[idx].pickSlab()
        return slab.allocate()

    Pool::deallocate(ptr,N):
        idx   ← router(N)
        slab  ← classes[idx].findOwner(ptr)
        slab.deallocate(ptr)
        if(slab.empty()) maybe release it

Why it exists
    Hides slab life-cycle details and gives callers an everyday allocator interface.


3. PoolAllocator  (file: PoolAllocator.hpp)
------------------------------------------
Role
    • STL-compatible allocator adapter.
    • Template <T>; forwards allocate/deallocate to the Pool.

What it must supply (Allocator concept)
    value_type, pointer, size_type, etc.
    allocate(n)   → Pool.allocate(n*sizeof(T))
    deallocate(p) → Pool.deallocate(p,n*sizeof(T))

Why it exists
    Lets standard containers use the slab pool without code changes.
    Example:
        using VecInt = std::vector<int, slab::PoolAllocator<int>>;


Putting it all together
-----------------------
Application / STL containers
            │
            ▼
  PoolAllocator<T>
            │
            ▼
         Pool
      ┌────────────┐
      │size class 0│─► list<Slab>
      │size class 1│─► list<Slab>
      │size class 2│─► list<Slab>
      └────────────┘

Benefits
    • Predictable constant-time latency.
    • No external fragmentation inside a slab.
    • Bounded internal fragmentation (sizes rounded up).
    • Scales via per-thread caches or lock-free techniques. 